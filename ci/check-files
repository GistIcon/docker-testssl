#!/bin/bash
set -e
set -u

. ci/helpers.sh

usage() {
  cat <<EOF
  Usage: "$0" [-dh] [-v level]
    -d          debug, shorthand for -v2
    -h          help (this screen)
    -v level    verbosity, where level is 0, 1, or 2
EOF
}

main() {
  local code=0

  # https://github.com/koalaman/shellcheck/wiki/SC2044
  while IFS= read -r -d '' file; do
    debug checking "${file}"
    if is_directory "${file}"; then
      continue # A git submodule appears as a directory in "git ls-files".
    fi
    check_binary "${file}"        || code=1
    check_shell "${file}"         || code=1
    check_whitespace "${file}"    || code=1
  done < <(git ls-files -z)
  return ${code}
}

is_binary() {
  local file="$1"
  readonly file
  local RC=1

  _output="$(file --mime --dereference "${file}")"
  if [[ ${_output} =~ inode/x-empty ]]; then
    : # Don't consider zero-sized file to be binary.
  elif [[ "$(stat -c %s "${file}")" =~ "^0$" ]]; then
    : # Don't consider zero-sized file to be binary.
  elif [[ ${_output} =~ binary$ ]]; then
    RC=0
  fi

  return ${RC}
}

is_directory() {
  local file="$1"
  readonly file
  file --mime --dereference "${file}" | grep 'directory' &> /dev/null
}

is_shell_script() {
  local file="$1"
  readonly file
  local RC=1

  if file --mime --dereference "${file}" | grep 'shellscript' &> /dev/null; then
    RC=0
  elif [[ "${file}" =~ \.sh$ ]]; then
    RC=0
  fi

  return ${RC}
}

check_binary() {
  local file="$1"
  readonly file
  local RC=0

  if [[ "${file}" =~ assets/ ]]; then
    RC=0 # Binaries are allowed in the assets directory.
  elif is_binary "${file}"; then
    err \""${file}"\" is a binary file
    RC=1
  fi

  return ${RC}
}

check_shell() {
  local file="$1"
  readonly file
  local RC=1

  if ! is_shell_script "${file}"; then
    return 0
  fi

  bash -n "${file}" && RC=0

  if command -v shellcheck &> /dev/null; then
    # https://github.com/koalaman/shellcheck
    shellcheck "${file}" && RC=0
  else
    warn unable to find \"shellcheck\" in \$PATH ... skipping shellcheck checks
  fi

  return ${RC}
}

check_whitespace() {
  local file="$1"
  readonly file
  local RC=1

  if is_binary "${file}"; then
    # Binary files can have trailing whitespace.
    return 0
  fi

  if [[ ${verbosity} -ge 2 ]]; then
    grep -E '\s$' "${file}" -n
  else
    grep -E '\s$' "${file}" &> /dev/null
  fi

  case $? in
    0)
      # Found whitespace.
      RC=1
      err \""${file}"\" has trailing whitespace
      ;;
    1)
      # Did not find whitespace.
      RC=0
      ;;
    2)
      # grep command failed.
      exit 2
      ;;
  esac

  return ${RC}
}

################################################################################
# Program execution starts here.
################################################################################

# Default values.
readonly LOCAL_SHELLCHECK_EXCLUDES="-e SC1091"
export SHELLCHECK_OPTS="${SHELLCHECK_OPTS:-"${LOCAL_SHELLCHECK_EXCLUDES=}"}"

# http://wiki.bash-hackers.org/howto/getopts_tutorial
while getopts ":dhv:" opt; do
  case ${opt} in
    d)
      verbosity=2
      ;;
    h)
      usage
      exit 0
      ;;
    v)
      verbosity=${OPTARG}
      ;;
    :)
      usage
      err option -"${OPTARG}" requires an argument
      exit 1
      ;;
    \?|*)
      usage
      err invalid option -"${OPTARG}"
      exit 1
      ;;
  esac
done

# After the shift, $* contains non-option arguments.
shift $((OPTIND-1))

main
